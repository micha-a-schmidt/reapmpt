(* The package `REAP' is written for Mathematica 7 and is distributed under the
terms of GNU Public License http://www.gnu.org/copyleft/gpl.html *)





BeginPackage["REAP`RGESUSYSU5`",{"REAP`RGESymbol`", "REAP`RGESolver`","REAP`RGEUtilities`","REAP`RGETakagi`", "REAP`RGEParameters`","REAP`RGEInitial`","MixingParameterTools`MPT3x3`",
"REAP`RGESM`","REAP`RGEMSSM0N`","REAP`RGESM0N`","REAP`RGE2HDM`","REAP`RGE2HDM0N`","REAP`RGEMSSM`"(* transtions to these models are possible *)
}];

Print["Warning: The RG equations have not been cross checked yet. Do not
trust the calculations!"];

<PERL>
my $modelname="SUSYSU5";

my %OutFunc=( "RGERaw"=>"GetRawSolution",
	   "RGEM\\[Nu]r"=>"GetM\\[Nu]r",
	   "RGEAll"=>"GetSolution",
	   "RGEM\\[Nu]"=>"GetM\\[Nu]",
	   "RGEMe"=>"GetMe",
	   "RGEMu"=>"GetMu",
	   "RGEMd"=>"GetMd",
	   "RGECoupling"=>"GetCoupling",
	   "RGE\\[Alpha]"=>"Get\\[Alpha]",
	   "RGERawM\\[Nu]r"=>"GetRawM\\[Nu]r",
	   "RGERawY\\[Nu]"=>"GetRawY\\[Nu]",
	   "RGE\\[Kappa]"=>"Get\\[Kappa]",
	   "RGEY\\[Nu]"=>"GetY\\[Nu]",
	   "RGEYe"=>"GetYe",
	   "RGEYu"=>"GetYu",
	   "RGEYd"=>"GetYd",
	   "RGEMixingParameters"=>"GetMixingParameters",
	   "RGETwistingParameters"=>"GetTwistingParameters",
	   "RGEM1Tilde"=>"GetM1Tilde",
	   "RGE\\[Epsilon]1Max"=>"Get\\[Epsilon]1Max",
	   "RGE\\[Epsilon]1"=>"Get\\[Epsilon]1",
	   "RGE\\[Epsilon]Max"=>"Get\\[Epsilon]Max",
	   "RGE\\[Epsilon]"=>"Get\\[Epsilon]",
	   "RGEPoleMTop"=>"GetPoleMTop",
	   );

my %TransFunc=(
		"MSSM"=>"TransMSSM",
		"SUSYSU5"=>"TransSUSYSU5",
	     );

RegisterModel($modelname,%OutFunc, %TransFunc);

print "

Begin[\"`Private`\"];

Map[Needs,{\"REAP`RGESymbol`\", \"REAP`RGESolver`\",\"REAP`RGEUtilities`\",\"REAP`RGETakagi`\", \"REAP`RGEParameters`\",\"REAP`RGEInitial`\",\"MixingParameterTools`MPT3x3`\",\"REAP`RGESM`\",\"REAP`RGEMSSM0N`\",\"REAP`RGESM0N`\",\"REAP`RGE2HDM`\",\"REAP`RGE2HDM0N`\",\"REAP`RGEMSSM`\"}];

ModelName=\"$modelname\";
ModelVariants={\"1Loop\"};
RGE={RGE1Loop};

";

OutputFunctions($modelname,"RGEOutput.cxml",%OutFunc);
Functions($modelname,"RGEFunctions.cxml");
</PERL>
(*
my %TransFunc=(
		"SM"=>"TransSM",
		"SM0N"=>"TransSM0N",
		"MSSM"=>"TransMSSM",
		"SUSYSU5"=>"TransSUSYSU5",
		"MSSM0N"=>"TransMSSM0N",
		"2HDM"=>"Trans2HDM",
		"2HDM0N"=>"Trans2HDM0N",
	     );
*)

(* definitions for the Minimal Supersymmetric Standard Model (MSSM) *)

ClearAll[RGEOptions];
RGEOptions;
Options[RGEOptions]={   RGEModelVariant->"1Loop", (* different variation of the model *)
			  RGEAutoGenerated->False, (* used to find automatically generated entries *)
			RGEPrecision->6, (* precision to find transitions *)
                        RGEMaxNumberIterations->20, (* maximum number of iterations in the loops to search transitions *)
                        RGEvEW->246, (* vev of the SM Higgs *)
                        RGEtan\[Beta]->50, (* tan \[Beta]=vu/vd *)  
                        RGEIntegratedOut->0, (* number of the integrated out neutrinos *)
			Method->StiffnessSwitching, (* option of NDSolve *)
			RGESearchTransition->True, (* enables/disables the automatic search for transitions *)
                        RGEThresholdFactor->1 (* neutrinos are integrated out at RGEThresholdFactor*Mass *)
			}; (* options of the model *)

                        
Parameters={g,Yu,Yd,Y\[Nu],\[Kappa],M\[Nu]r,m};
ParameterSymbols={RGEg,RGEYu,RGEYd,RGEY\[Nu],RGE\[Kappa],RGEM\[Nu]r,RGEm};

ClearAll[Initial];
Initial={
{"GUT",{
	RGEg->0.7044110331165641,
	RGEYd->RGEGetYd[RGEyd,RGEys,RGEyb,RGEq\[Theta]12,RGEq\[Theta]13,RGEq\[Theta]23,RGEq\[Delta],RGEq\[Delta]e,RGEq\[Delta]\[Mu],RGEq\[Delta]\[Tau],RGEq\[CurlyPhi]1,RGEq\[CurlyPhi]2],
	RGEYu->DiagonalMatrix[{RGEyu,RGEyc,RGEyt}],
	RGE\[Kappa]->0*IdentityMatrix[3],
	RGEM\[Nu]r->RGEGetM[RGE\[Theta]12,RGE\[Theta]13,RGE\[Theta]23,RGE\[Delta],RGE\[Delta]e,RGE\[Delta]\[Mu],RGE\[Delta]\[Tau],RGE\[CurlyPhi]1,RGE\[CurlyPhi]2,RGEMlightest,RGE\[CapitalDelta]m2atm,RGE\[CapitalDelta]m2sol,RGEMassHierarchy,RGEvu,RGEY\[Nu]],
	RGEq\[Theta]12 -> 12.651 Degree,
	RGEq\[Theta]13 -> 0.147249 Degree, 
	RGEq\[Theta]23 -> 1.82387 Degree,
	RGEq\[Delta] -> 293.06 Degree,
	RGEq\[CurlyPhi]1 -> 0 Degree,
	RGEq\[CurlyPhi]2 -> 0 Degree, 
	RGEq\[Delta]e -> 0 Degree,
	RGEq\[Delta]\[Mu] -> 0 Degree,
	RGEq\[Delta]\[Tau] -> 0 Degree,
	RGEMassHierarchy -> "n",
	RGE\[Theta]12 -> 27 Degree,
	RGE\[Theta]13 -> 0 Degree, 
	RGE\[Theta]23 -> 45 Degree,
	RGE\[Delta] -> 0 Degree,
	RGE\[Delta]e -> 0 Degree,
	RGE\[Delta]\[Mu] -> 0 Degree,
	RGE\[Delta]\[Tau] -> 0 Degree,
	RGE\[CurlyPhi]1 -> 0 Degree,
	RGE\[CurlyPhi]2 -> 0 Degree, 
	RGEMlightest -> 0.02,
	RGE\[CapitalDelta]m2atm -> 4*10^-3, 
	RGE\[CapitalDelta]m2sol -> 1.6 10^-4,
	RGEY\[Nu]33 -> 0.5,
	RGEY\[Nu]Ratio -> 0.1,
	RGEY\[Nu]->RGEGetY\[Nu][RGEY\[Nu]33,RGEY\[Nu]Ratio],
	RGEYe->DiagonalMatrix[{RGEye,RGEy\[Mu],RGEy\[Tau]}],
	RGEyu -> 0.00104/RGEvu*Sqrt[2],
	RGEyc -> 0.302/RGEvu*Sqrt[2],
	RGEyt -> 129/RGEvu*Sqrt[2],
	RGEyd -> 0.00133/RGEvd*Sqrt[2],
	RGEys -> 0.0265/RGEvd*Sqrt[2],
	RGEyb ->  1.00/RGEvd*Sqrt[2],
	RGEye -> 0.32502032*10^-3*Sqrt[2]/RGEve,
	RGEy\[Mu] -> 68.59813*10^-3*Sqrt[2]/RGEve,
	RGEy\[Tau] -> 1171.4*10^-3*Sqrt[2]/RGEve
}
}
}; (* a list containing suggestions for initial values *)



ClearAll[RGE1Loop];
RGE1Loop:={	D[g[t],t]==Betag[g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]],
		D[Yu[t],t]==BetaYu[g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]],
		D[Yd[t],t]==BetaYd[g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]],
		D[Y\[Nu][t],t]==BetaY\[Nu][g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]],
		D[\[Kappa][t],t]==Beta\[Kappa][g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]],
		D[M\[Nu]r[t],t]==BetaM\[Nu]r[g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]],
		D[m[t],t]==Betam[g[t],Yu[t],Yd[t],Y\[Nu][t],\[Kappa][t],M\[Nu]r[t],m[t]]
}; (* renormalization group equations of the MSSM ( 1 Loop ) *)



(* Beta functions of the MSSM *)
ClearAll[Betag, BetaYu, BetaYd, BetaYe, BetaY\[Nu], Beta\[Kappa], BetaM\[Nu]r, Beta\[Lambda]];

(* 1 loop contributions *)

Betag[g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_] :=
	-3 * 1/(16*Pi^2) * g^3;


BetaYu[g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_,m_] := 1/(16*Pi^2) * (
          (Dagger[Yu].Yu+Dagger[Yd].Yd).Yu
          Yu.(Conjugate[Yu].Transpose[Yu]+Conjugate[Yd].Transpose[Yd])
          +(-96/5 * g^2 +Tr[Dagger[Yu].Yu]+Tr[Dagger[Y\[Nu]].Y\[Nu]]) Yu);

BetaYd[g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_,m_] := 1/(16*Pi^2) * (
          (Dagger[Yu].Yu+Dagger[Yd].Yd).Yu
          Yu.(Conjugate[Yu].Transpose[Yu]+Conjugate[Yd].Transpose[Yd])
          +(-96/5 * g^2 +Tr[Dagger[Yu].Yu]+Tr[Dagger[Y\[Nu]].Y\[Nu]]) Yu)


BetaY\[Nu][g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_,m_] := 1/(16*Pi^2) * (


Beta\[Kappa][g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_,m_] :=1/(16*Pi^2) * (
	\[Kappa].(
        + Dagger[Ye].Ye
        + Dagger[Y\[Nu]].Y\[Nu]
        )
	+ (
        + Transpose[Ye].Conjugate[Ye]
	+ Transpose[Y\[Nu]].Conjugate[Y\[Nu]]
        ).\[Kappa]
        + (
	- (6/5)*g^2
	- 6*g^2
	+ 6*Tr[Dagger[Yu].Yu]
        + 2*Tr[Dagger[Y\[Nu]].Y\[Nu]]
        )*\[Kappa]
        );

BetaM\[Nu]r[g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_,m_] := 1/(16*Pi^2) * (
          2*M\[Nu]r.Conjugate[Y\[Nu]].Transpose[Y\[Nu]]
	  + 2*Y\[Nu].Dagger[Y\[Nu]].M\[Nu]r);


Betam[g_,Yu_,Yd_,Y\[Nu]_,\[Kappa]_,M\[Nu]r_,m_] := 1/(16*Pi^2) * (
          2*M\[Nu]r.Conjugate[Y\[Nu]].Transpose[Y\[Nu]]
	  + 2*Y\[Nu].Dagger[Y\[Nu]].M\[Nu]r);




	  

(* transition functions *)

ClearAll[TransSUSYSU5];
TransSUSYSU5[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated,lIntegrateOut, lUforM,lToIntegratedOut,lFromIntegratedOut},
(* make a transition from the SUSYSU5 to the SUSYSU5 *)

(* evaluate the options *)
(* evaluate IntegratedOut in pToOpts and pFromOpts *)
        lToOpts;
        Options[lToOpts]=Options[RGEOptions];
        SetOptions[lToOpts,RGEFilterOptions[lToOpts,pToOpts]];
	lToIntegratedOut=RGEIntegratedOut/.Options[lToOpts,RGEIntegratedOut];
        lFromOpts;
        Options[lFromOpts]=Options[RGEOptions];
        SetOptions[lFromOpts,RGEFilterOptions[lFromOpts,pFromOpts]];
	lFromIntegratedOut=RGEIntegratedOut/.Options[lFromOpts,RGEIntegratedOut];

(* calculate the new parameters *)
	{lg,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

	If[lFromIntegratedOut>lToIntegratedOut,
	   (* Print["The model ", RGEGetModel[Exp[pScale]], " at the scale ",
	   Exp[pScale]," pretends to have more particles, but new particles can
	   not be added: ",lFromIntegratedOut,"->",lToIntegratedOut, " Thus the
	   model is changed."]; *)
	   RGEChangeOptions[Exp[pScale],RGEIntegratedOut->lFromIntegratedOut];
	   lToIntegratedOut=lFromIntegratedOut;
	   (*Throw[{lFromIntegratedOut,lToIntegratedOut},RGECanNotAddNewParticles];*)
	];
	If[lToIntegratedOut>lFromIntegratedOut,
		lIntegrateOut=lToIntegratedOut-lFromIntegratedOut;
			l\[Kappa]+=RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,lIntegrateOut];
			lY\[Nu]=RGEIntegrateOutY\[Nu][lY\[Nu]Rotated, lIntegrateOut];
			lM\[Nu]r=RGEIntegrateOutM[lM\[Nu]rRotated, lIntegrateOut];
	];

        Return[{RGEg->lg,RGEYu->lYu,RGEYd->lYd,RGEYe->lYe,RGEY\[Nu]->lY\[Nu],RGE\[Kappa]->l\[Kappa],RGEM\[Nu]r->lM\[Nu]r}];
];

ClearAll[TransMSSM];
TransMSSM[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated,lIntegrateOut, lUforM,lToIntegratedOut,lFromIntegratedOut},
(* make a transition from the MSSM to the MSSM *)

(* evaluate the options *)
(* evaluate IntegratedOut in pToOpts and pFromOpts *)
        lToOpts;
        Options[lToOpts]=Options[RGEOptions];
        SetOptions[lToOpts,RGEFilterOptions[lToOpts,pToOpts]];
	lToIntegratedOut=RGEIntegratedOut/.Options[lToOpts,RGEIntegratedOut];
        lFromOpts;
        Options[lFromOpts]=Options[RGEOptions];
        SetOptions[lFromOpts,RGEFilterOptions[lFromOpts,pFromOpts]];
	lFromIntegratedOut=RGEIntegratedOut/.Options[lFromOpts,RGEIntegratedOut];

(* calculate the new parameters *)
	{lg,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

	If[lFromIntegratedOut>lToIntegratedOut,
	   (* Print["The model ", RGEGetModel[Exp[pScale]], " at the scale ",
	   Exp[pScale]," pretends to have more particles, but new particles can
	   not be added: ",lFromIntegratedOut,"->",lToIntegratedOut, " Thus the
	   model is changed."]; *)
	   RGEChangeOptions[Exp[pScale],RGEIntegratedOut->lFromIntegratedOut];
	   lToIntegratedOut=lFromIntegratedOut;
	   (*Throw[{lFromIntegratedOut,lToIntegratedOut},RGECanNotAddNewParticles];*)
	];
	If[lToIntegratedOut>lFromIntegratedOut,
		lIntegrateOut=lToIntegratedOut-lFromIntegratedOut;
			l\[Kappa]+=RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,lIntegrateOut];
			lY\[Nu]=RGEIntegrateOutY\[Nu][lY\[Nu]Rotated, lIntegrateOut];
			lM\[Nu]r=RGEIntegrateOutM[lM\[Nu]rRotated, lIntegrateOut];
	];

        Return[{RGEg1->lg,RGEg2->lg,RGEg3->lg,RGEYu->lYu,RGEYd->lYd,RGEYe->lYe,RGEY\[Nu]->lY\[Nu],RGE\[Kappa]->l\[Kappa],RGEM\[Nu]r->lM\[Nu]r}];
];



ClearAll[TransMSSM0N];
TransMSSM0N[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated, lUforM},
(* make a transition from the MSSM to the MSSM w/o heavy neutrinos *)

(* calculate the new parameters *)
	{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

        l\[Kappa]+= RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,Length[lM\[Nu]r]];

        Return[{RGEg1->lg1,RGEg2->lg2,RGEg3->lg3,RGEYu->lYu,RGEYd->lYd,RGEYe->lYe,RGE\[Kappa]->l\[Kappa]}];
];


ClearAll[Trans2HDM];
Trans2HDM[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated,lIntegrateOut, lUforM,lToIntegratedOut,lFromIntegratedOut,le,lu,ld,l\[Nu],lTosb,lTocb,lsb,lcb},
(* make a transition from the MSSM to the MSSM *)

(* evaluate the options *)
(* evaluate IntegratedOut in pToOpts and pFromOpts *)
        lToOpts;
        Options[lToOpts]=Options[RGEGetModelOptions["2HDM"][[1,2]]];
        SetOptions[lToOpts,RGEFilterOptions[lToOpts,pToOpts]];
	lToIntegratedOut=RGEIntegratedOut/.Options[lToOpts,RGEIntegratedOut];
        lFromOpts;
        Options[lFromOpts]=Options[RGEOptions];
        SetOptions[lFromOpts,RGEFilterOptions[lFromOpts,pFromOpts]];
	lFromIntegratedOut=RGEIntegratedOut/.Options[lFromOpts,RGEIntegratedOut];

(* calculate the new parameters *)
	{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

	If[lFromIntegratedOut>lToIntegratedOut,
		   (* Print["The model ", RGEGetModel[Exp[pScale]], " at the
		   scale ", Exp[pScale]," pretends to have more particles, but
		   new particles can not be added:
		   ",lFromIntegratedOut,"->",lToIntegratedOut, " Thus the model
		   is changed."]; *)
		   RGEChangeOptions[Exp[pScale],RGEIntegratedOut->lFromIntegratedOut];
		   lToIntegratedOut=lFromIntegratedOut;
		   (*Throw[{lFromIntegratedOut,lToIntegratedOut},RGECanNotAddNewParticles];*)
	   ];
	If[lToIntegratedOut>lFromIntegratedOut,
		lIntegrateOut=lToIntegratedOut-lFromIntegratedOut;
                
			l\[Kappa]+=RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,lIntegrateOut];
			lY\[Nu]=RGEIntegrateOutY\[Nu][lY\[Nu]Rotated, lIntegrateOut];
			lM\[Nu]r=RGEIntegrateOutM[lM\[Nu]rRotated, lIntegrateOut];
	];
	lcb=1/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	lsb=RGEtan\[Beta]/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	lTocb=1/Sqrt[1+RGEtan\[Beta]^2]/.Options[lToOpts,RGEtan\[Beta]];
	lTosb=RGEtan\[Beta]/Sqrt[1+RGEtan\[Beta]^2]/.Options[lToOpts,RGEtan\[Beta]];

	lu=lsb/((RGEzu/.Options[lToOpts,RGEzu]).{lTocb,lTosb});
	ld=lcb/((RGEzd/.Options[lToOpts,RGEzd]).{lTocb,lTosb});
	l\[Nu]=lsb/((RGEz\[Nu]/.Options[lToOpts,RGEz\[Nu]]).{lTocb,lTosb});
	le=lcb/lTocb;

	
        Return[{RGEg1->lg1,RGEg2->lg2,RGEg3->lg3,RGEYu->lYu*lu,RGEYd->lYd*ld,RGEYe->lYe*le,RGEY\[Nu]->lY\[Nu]*l\[Nu],RGE\[Kappa]1->(RGEz\[Nu]/.Options[lToOpts,RGEz\[Nu]])[[1]]*l\[Kappa]*(l\[Nu])^2,RGE\[Kappa]2->(RGEz\[Nu]/.Options[lToOpts,RGEz\[Nu]])[[2]]*l\[Kappa]*(l\[Nu])^2,RGEM\[Nu]r->lM\[Nu]r,RGE\[Lambda]1->(RGE\[Lambda]1/.Options[lToOpts,RGE\[Lambda]1]),RGE\[Lambda]2->(RGE\[Lambda]2/.Options[lToOpts,RGE\[Lambda]2]),RGE\[Lambda]3->(RGE\[Lambda]3/.Options[lToOpts,RGE\[Lambda]3]),RGE\[Lambda]4->(RGE\[Lambda]4/.Options[lToOpts,RGE\[Lambda]4]),RGE\[Lambda]5->(RGE\[Lambda]5/.Options[lToOpts,RGE\[Lambda]5])}];
];


ClearAll[Trans2HDM0N];
Trans2HDM0N[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated, lUforM,lsb,lcb,lTosb,lTocb,lu,ld,le,l\[Nu]},
(* make a transition from the MSSM to the MSSM w/o heavy neutrinos *)

        lToOpts;
        Options[lToOpts]=Options[RGEGetModelOptions["2HDM0N"][[1,2]]];
        SetOptions[lToOpts,RGEFilterOptions[lToOpts,pToOpts]];
        lFromOpts;
        Options[lFromOpts]=Options[RGEOptions];
        SetOptions[lFromOpts,RGEFilterOptions[lFromOpts,pFromOpts]];
(* calculate the new parameters *)
	{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

        l\[Kappa]+= RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,Length[lM\[Nu]r]];

	lcb=1/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	lsb=RGEtan\[Beta]/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	lTocb=1/Sqrt[1+RGEtan\[Beta]^2]/.Options[lToOpts,RGEtan\[Beta]];
	lTosb=RGEtan\[Beta]/Sqrt[1+RGEtan\[Beta]^2]/.Options[lToOpts,RGEtan\[Beta]];

	lu=lsb/((RGEzu/.Options[lToOpts,RGEzu]).{lTocb,lTosb});
	ld=lcb/((RGEzd/.Options[lToOpts,RGEzd]).{lTocb,lTosb});
	l\[Nu]=lsb/((RGEz\[Nu]/.Options[lToOpts,RGEz\[Nu]]).{lTocb,lTosb});
	le=lcb/lTocb;


        Return[{RGEg1->lg1,RGEg2->lg2,RGEg3->lg3,RGEYu->lYu*lu,RGEYd->lYd*ld,RGEYe->lYe*le,RGE\[Kappa]1->(RGEz\[Nu]/.Options[lToOpts,RGEz\[Nu]])[[1]]*l\[Kappa]*(l\[Nu])^2,RGE\[Kappa]2->(RGEz\[Nu]/.Options[lToOpts,RGEz\[Nu]])[[2]]*l\[Kappa]*(l\[Nu])^2,RGE\[Lambda]1->(RGE\[Lambda]1/.Options[lToOpts,RGE\[Lambda]1]),RGE\[Lambda]2->(RGE\[Lambda]2/.Options[lToOpts,RGE\[Lambda]2]),RGE\[Lambda]3->(RGE\[Lambda]3/.Options[lToOpts,RGE\[Lambda]3]),RGE\[Lambda]4->(RGE\[Lambda]4/.Options[lToOpts,RGE\[Lambda]4]),RGE\[Lambda]5->(RGE\[Lambda]5/.Options[lToOpts,RGE\[Lambda]5])}];
];


ClearAll[TransSM];
TransSM[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated,lIntegrateOut, lUforM,lToIntegratedOut,lFromIntegratedOut, lsb,lcb},
(* make a transition from the MSSM to the SM *)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!depends on RGESM.m !!!!!!!!!!!!!!!!!!!!!!!!!
the dependencies are marked by !!! *)


(* evaluate the options *)
(* evaluate IntegratedOut in pToOpts and pFromOpts *)
        lToOpts;
        Options[lToOpts]=Options[RGEGetModelOptions["SM"][[1,2]]];
        SetOptions[lToOpts,RGEFilterOptions[lToOpts,pToOpts]];
	lToIntegratedOut=RGEIntegratedOut/.Options[lToOpts,RGEIntegratedOut];
        lFromOpts;
        Options[lFromOpts]=Options[RGEOptions];
        SetOptions[lFromOpts,RGEFilterOptions[lFromOpts,pFromOpts]];
	lFromIntegratedOut=RGEIntegratedOut/.Options[lFromOpts,RGEIntegratedOut];
	
(* calculate the new parameters *)
	{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

	If[lFromIntegratedOut>lToIntegratedOut,
		   (* Print["The model ", RGEGetModel[Exp[pScale]], " at the
		   scale ", Exp[pScale]," pretends to have more particles, but
		   new particles can not be added:
		   ",lFromIntegratedOut,"->",lToIntegratedOut, " Thus the model
		   is changed."]; *)
		   RGEChangeOptions[Exp[pScale],RGEIntegratedOut->lFromIntegratedOut];
		   lToIntegratedOut=lFromIntegratedOut;
		   (*Throw[{lFromIntegratedOut,lToIntegratedOut},RGECanNotAddNewParticles];*)
	   ];
	If[lToIntegratedOut>lFromIntegratedOut,
		lIntegrateOut=lToIntegratedOut-lFromIntegratedOut;

			l\[Kappa]+= RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,lIntegrateOut];
			lY\[Nu]= RGEIntegrateOutY\[Nu][lY\[Nu]Rotated, lIntegrateOut];
			lM\[Nu]r= RGEIntegrateOutM[lM\[Nu]rRotated, lIntegrateOut];
	];
	lcb=1/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	lsb=RGEtan\[Beta]/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	Return[{RGEg1->lg1,RGEg2->lg2,RGEg3->lg3,RGEYu->lYu*lsb,RGEYd->lYd*lcb,RGEYe->lYe*lcb,RGEY\[Nu]->lY\[Nu]*lsb,RGE\[Kappa]->l\[Kappa]*(lsb)^2,RGEM\[Nu]r->lM\[Nu]r,RGE\[Lambda]->(RGE\[Lambda]/.Options[lToOpts,RGE\[Lambda]])}];
];



ClearAll[TransSM0N];
TransSM0N[pScale_?NumericQ,pDirection_?NumericQ,pSolution_,pToOpts_,pFromOpts_]:=Block[{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],lY\[Nu]Rotated,l\[Kappa],lM\[Nu]r,lM\[Nu]rRotated, lUforM,lsb,lcb},
(* make a transition from the MSSM to the SM w/o heavy neutrinos *)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!depends on RGESM.m !!!!!!!!!!!!!!!!!!!!!!!!!
the dependencies are marked by !!! *)


        lFromOpts;
        Options[lFromOpts]=Options[RGEOptions];
        SetOptions[lFromOpts,RGEFilterOptions[lFromOpts,pFromOpts]];
        lToOpts;
        Options[lToOpts]=Options[RGEGetModelOptions["SM0N"][[1,2]]];
        SetOptions[lToOpts,RGEFilterOptions[lToOpts,pToOpts]];
(* calculate the new parameters *)

	{lg1,lg2,lg3,lYu,lYd,lYe,lY\[Nu],l\[Kappa],lM\[Nu]r}=(ParametersFunc[ pScale ]/.pSolution)[[1]];
	{lM\[Nu]rRotated,lY\[Nu]Rotated}=RGERotateM[ lM\[Nu]r,lY\[Nu] ]; (*rotation matrix for lM\[Nu]r*)

	l\[Kappa]+= RGEKappaMatching[lM\[Nu]rRotated,lY\[Nu]Rotated,Length[lM\[Nu]r]];

	lcb=1/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	lsb=RGEtan\[Beta]/Sqrt[1+RGEtan\[Beta]^2]/.Options[lFromOpts,RGEtan\[Beta]];
	Return[{RGEg1->lg1,RGEg2->lg2,RGEg3->lg3,RGEYu->lYu*lsb,RGEYd->lYd*lcb,RGEYe->lYe*lcb,RGE\[Kappa]->l\[Kappa]*(lsb)^2,RGE\[Lambda]->(RGE\[Lambda]/.Options[lToOpts,RGE\[Lambda]])}];
];




(* internal functions *)

ClearAll[ParametersFunc];
ParametersFunc[pScale_]:={g1[pScale],g2[pScale],g3[pScale],Yu[pScale],Yd[pScale],Ye[pScale],Y\[Nu][pScale],\[Kappa][pScale],M\[Nu]r[pScale]};

ClearAll[SetInitial];
SetInitial[pBoundary_?NumericQ,pInitial_]:=Block[{},
(* sets the initial values *)
   Return[		{g1[pBoundary]==RGEg1,
			g2[pBoundary]==RGEg2,
			g3[pBoundary]==RGEg3,
			Yu[pBoundary]==RGEYu,
			Yd[pBoundary]==RGEYd,
			Ye[pBoundary]==RGEYe,
			Y\[Nu][pBoundary]==RGEY\[Nu],
			\[Kappa][pBoundary]==RGE\[Kappa],
			M\[Nu]r[pBoundary]==RGEM\[Nu]r
			}//.pInitial
			];
];

End[]; (* end of `Private`*)


EndPackage[];
